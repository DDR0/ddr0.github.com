//@ sourceMappingURL=setup.map
// Generated by CoffeeScript 1.6.1
(function() {
  var addBldg, addNewRoadTiles, addTile, advanceRoadTileAgent, buildingLayer, c, cacheEaselValues, closestTile, commercialAxisIsVertical, commercialUndesirability, configureCanvas, groundLayer, handleComplete, initializeCity, knownProperties, knownRoadTiles, newTile, pointsAreEqual, populateProperty, propertyGen, propertyValues, queue, reverse, roadGen, roadTileAgents, stage, tileHeight, tileSheet, tileSheetRects, tileWidth, windowMidpoint,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  tileWidth = 36;

  tileHeight = 18;

  c = console;

  tileSheet = tileSheetRects = stage = windowMidpoint = commercialAxisIsVertical = null;

  groundLayer = buildingLayer = null;

  handleComplete = function() {
    jQuery.globalEval(queue.getResult('_').innerHTML);
    jQuery.globalEval(queue.getResult('easel').innerHTML);
    tileSheet = new createjs.Bitmap(queue.getResult('tiles'));
    configureCanvas();
    cacheEaselValues();
    return initializeCity();
  };

  queue = new createjs.LoadQueue();

  queue.addEventListener("complete", handleComplete);

  queue.loadManifest((function(path) {
    return [
      {
        id: "_",
        src: path + "underscore-min.js"
      }, {
        id: "easel",
        src: path + "easeljs-0.6.0.min.js"
      }, {
        id: "tiles",
        src: path + "tiles.png"
      }
    ];
  })('background town/'));

  configureCanvas = function() {
    return $('#background-city').css({
      position: 'absolute',
      top: 0,
      left: 0,
      width: $(window).width(),
      height: $(window).height(),
      'z-index': -1
    }).attr({
      width: $(window).width(),
      height: $(window).height()
    });
  };

  cacheEaselValues = function() {
    return tileSheetRects = (function(w, h) {
      return {
        road19: new createjs.Rectangle(0 * w, 0 * h, w, h),
        road37: new createjs.Rectangle(1 * w, 0 * h, w, h),
        road79: new createjs.Rectangle(2 * w, 0 * h, w, h),
        road39: new createjs.Rectangle(3 * w, 0 * h, w, h),
        road13: new createjs.Rectangle(4 * w, 0 * h, w, h),
        road17: new createjs.Rectangle(5 * w, 0 * h, w, h),
        outline: new createjs.Rectangle(6 * w, 0 * h, w + 2, h + 1),
        background: new createjs.Rectangle(0 * w, 1 * h, w, h),
        road1379: new createjs.Rectangle(1 * w, 1 * h, w, h),
        road137: new createjs.Rectangle(2 * w, 1 * h, w, h),
        road139: new createjs.Rectangle(3 * w, 1 * h, w, h),
        road379: new createjs.Rectangle(4 * w, 1 * h, w, h),
        road179: new createjs.Rectangle(5 * w, 1 * h, w, h),
        dashed19: new createjs.Rectangle(0 * w, 2 * h, w, h),
        dashed37: new createjs.Rectangle(1 * w, 2 * h, w, h),
        road7: new createjs.Rectangle(2 * w, 2 * h, w, h),
        road9: new createjs.Rectangle(3 * w, 2 * h, w, h),
        road3: new createjs.Rectangle(4 * w, 2 * h, w, h),
        road1: new createjs.Rectangle(5 * w, 2 * h, w, h),
        shop: new createjs.Rectangle(0 * w, 3 * h, w, h),
        house: new createjs.Rectangle(1 * w, 3 * h, w, h),
        parkinglot: new createjs.Rectangle(2 * w, 3 * h, w, h),
        grass: new createjs.Rectangle(3 * w, 3 * h, w, h),
        vacant: new createjs.Rectangle(4 * w, 3 * h, w, h),
        dirt: new createjs.Rectangle(5 * w, 3 * h, w, h)
      };
    })(tileWidth, tileHeight);
  };

  initializeCity = function() {
    var pane;
    stage = new createjs.Stage("background-city");
    stage.snapToPixel = true;
    groundLayer = new createjs.Container();
    stage.addChild(groundLayer);
    groundLayer.tiles = [];
    buildingLayer = new createjs.Container();
    stage.addChild(buildingLayer);
    buildingLayer.tiles = [];
    pane = $('#content-holder');
    windowMidpoint = closestTile(pane.width() / 2 + pane.position().left, pane.height() / 2 + pane.position().top);
    commercialAxisIsVertical = Math.random() < 0.5;
    roadGen(windowMidpoint);
    propertyGen(knownRoadTiles, true);
    return stage.update();
  };

  newTile = function(x, y, type) {
    var tile;
    if ((x / 2 + y / 2) % 1) {
      throw new Error("Tile is off grid. x:" + x + " and y:" + y + " should sum to an even number.");
    }
    tile = tileSheet.clone();
    tile.sourceRect = tileSheetRects[type];
    tile.x = x / 2 * tileWidth;
    tile.y = y / 2 * tileHeight;
    if (type === 'outline') {
      tile.x -= 1;
      tile.y -= 0.5;
    }
    tile.regX = tile.sourceRect.width / 2;
    tile.regY = tile.sourceRect.height / 2;
    return tile;
  };

  addTile = function(x, y, type) {
    var tile, _base, _base1, _ref, _ref1;
    tile = newTile(x, y, type);
    groundLayer.addChild(tile);
    ((_ref = (_base = ((_ref1 = (_base1 = groundLayer.tiles)[x]) != null ? _ref1 : _base1[x] = []))[y]) != null ? _ref : _base[y] = []).push(tile);
    return null;
  };

  addBldg = function(x, y, type) {
    var tile, _base, _base1, _ref, _ref1;
    tile = newTile(x, y, type);
    buildingLayer.addChild(tile);
    ((_ref = (_base = ((_ref1 = (_base1 = buildingLayer.tiles)[x]) != null ? _ref1 : _base1[x] = []))[y]) != null ? _ref : _base[y] = []).push(tile);
    return null;
  };

  closestTile = function(x, y) {
    var newX, newY;
    x *= 2;
    y *= 2;
    newX = Math.round(x / tileWidth);
    newY = Math.round(y / tileHeight);
    if ((newX / 2 + newY / 2) % 1) {
      if (Math.abs(x - newX < Math.abs(y - newY))) {
        if (x - newX < 0) {
          --newX;
        }
        if (x - newX >= 0) {
          ++newX;
        }
      } else {
        if (y - newY < 0) {
          --newY;
        }
        if (y - newY >= 0) {
          ++newY;
        }
      }
    }
    return new createjs.Point(newX, newY);
  };

  advanceRoadTileAgent = roadTileAgents = null;

  knownRoadTiles = [];

  addNewRoadTiles = function(walked) {
    var tile, _i, _len;
    for (_i = 0, _len = walked.length; _i < _len; _i++) {
      tile = walked[_i];
      addTile(tile.x, tile.y, 'outline');
      if (!(tile.connects[1] && tile.connects[9] || tile.connects[3] && tile.connects[7])) {
        addTile(tile.x, tile.y, propertyValues(tile) > 0.15 ? 'grass' : 'vacant');
      }
      addTile(tile.x, tile.y, 'road' + (tile.connects[1] * 1 || '') + (tile.connects[3] * 3 || '') + (tile.connects[7] * 7 || '') + (tile.connects[9] * 9 || ''));
    }
    return knownRoadTiles = knownRoadTiles.concat(walked);
  };

  reverse = function(dir) {
    return {
      1: 9,
      3: 7,
      7: 3,
      9: 1
    }[dir];
  };

  roadGen = function(startTile) {
    var advanceAgent, agent, agentNo, agents, branchChance, branchType, crossedExistingPath, newAgents, oldAgents, step, turnChance, turnTo, turnType, walk, walked, _i, _j, _len, _ref;
    branchChance = _.random(20, 40) / 100;
    branchType = _.random(10, 90) / 100;
    turnChance = _.random(10, 60) / 100;
    turnType = _.random(30, 70) / 100;
    walked = [startTile.clone()];
    walked[0].connects = {};
    agents = (function() {
      var _i, _results;
      _results = [];
      for (agentNo = _i = 1; _i <= 4; agentNo = ++_i) {
        _results.push({
          name: agentNo + 'a',
          position: startTile.clone(),
          directive: [1, 3, 0x7, 9][agentNo - 1],
          impetus: 3,
          step: 0,
          tileOn: walked[0]
        });
      }
      return _results;
    })();
    newAgents = [];
    oldAgents = [];
    crossedExistingPath = function(agent) {
      return _.find(walked, function(position) {
        return position.x === agent.position.x && position.y === agent.position.y;
      });
    };
    turnTo = function(facing, turnCCW) {
      return {
        "true": {
          1: 7,
          7: 9,
          9: 3,
          3: 1
        },
        "false": {
          7: 1,
          9: 7,
          3: 9,
          1: 3
        }
      }[turnCCW][facing];
    };
    walk = function(agent) {
      return (function(delta) {
        agent.position.x += delta.x;
        return agent.position.y += delta.y;
      })({1:{x:-1, y:+1}, //For some reason, this just confuses Coffeescript.
					  3:{x:+1, y:+1},
					  7:{x:-1, y:-1},
					  9:{x:+1, y:-1},
				}[agent.directive]);
    };
    advanceAgent = function(agent) {
      var branch, branchDir, crossedPath, turn, turnDir;
      walk(agent);
      if (agent.impetus) {
        --agent.impetus;
      }
      ++agent.step;
      crossedPath = crossedExistingPath(agent);
      if (crossedPath) {
        oldAgents.push(agent);
        agent.tileOn.connects[agent.directive] = true;
        return crossedPath.connects[reverse(agent.directive)] = true;
      } else {
        agent.tileOn.connects[agent.directive] = true;
        agent.tileOn = agent.position.clone();
        agent.tileOn.connects = {};
        agent.tileOn.connects[reverse(agent.directive)] = true;
        walked.push(agent.tileOn);
        branch = Math.random() < branchChance && !agent.impetus;
        branchDir = Math.random() < branchType;
        turn = Math.random() < turnChance && !agent.impetus;
        turnDir = Math.random() < turnType;
        if (branch && turn && !branchDir) {
          newAgents.push({
            name: agent.name + '-' + agent.step,
            position: agent.position.clone(),
            directive: turnTo(agent.directive, true),
            impetus: 3,
            step: agent.step,
            tileOn: agent.tileOn
          });
          agent.directive = turnTo(agent.directive, false);
        } else if (branch) {
          if (branchDir) {
            newAgents.push({
              name: agent.name + '-' + agent.step + 'a',
              position: agent.position.clone(),
              directive: turnTo(agent.directive, true),
              impetus: 3,
              step: agent.step,
              tileOn: agent.tileOn
            });
            newAgents.push({
              name: agent.name + '-' + agent.step + 'b',
              position: agent.position.clone(),
              directive: turnTo(agent.directive, false),
              impetus: 3,
              step: agent.step,
              tileOn: agent.tileOn
            });
          } else {
            newAgents.push({
              name: agent.name + '-' + agent.step,
              position: agent.position.clone(),
              directive: turnTo(agent.directive, turnDir),
              impetus: 3,
              step: agent.step,
              tileOn: agent.tileOn
            });
          }
        } else if (turn) {
          agent.directive = turnTo(agent.directive, turnDir);
        }
        if (branch || turn) {
          return agent.impetus = 3;
        }
      }
    };
    for (step = _i = 1, _ref = Math.min(startTile.x, startTile.y) / 2 - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; step = 1 <= _ref ? ++_i : --_i) {
      for (_j = 0, _len = agents.length; _j < _len; _j++) {
        agent = agents[_j];
        advanceAgent(agent);
      }
      agents = agents.filter(function(agent) {
        return !(__indexOf.call(oldAgents, agent) >= 0);
      }).concat(newAgents);
      newAgents = [];
      oldAgents = [];
    }
    advanceRoadTileAgent = advanceAgent;
    roadTileAgents = agents;
    return addNewRoadTiles(walked);
  };

  propertyValues = function(point, y) {
    var x;
    if (isFinite(y)) {
      x = point;
    } else {
      x = point.x;
      y = point.y;
    }
    return Math.abs(Math.sin(x) / 2 + Math.sin(y) / 2) + 0.1;
  };

  pointsAreEqual = function(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  };

  knownProperties = [];

  populateProperty = function(tiles) {
    tiles.forEach(function(tile) {
      addTile(tile.x, tile.y, 'outline');
      return addTile(tile.x, tile.y, propertyValues(tiles[0]) > 0.15 ? 'grass' : 'vacant');
    });
    addBldg(tiles[0].x, tiles[0].y, commercialUndesirability(tiles[0], windowMidpoint) < Math.min(windowMidpoint.x, windowMidpoint.y) * 0.15 ? 'shop' : 'house');
    return knownProperties.push(tiles);
  };

  propertyGen = function(roadTiles, exNihilo) {
    var existingProperties, relativeTile, tilesToTheSide, validPropertyLocation;
    relativeTile = function(tile, delta) {
      var dir, rTile;
      rTile = tile.clone();
      dir = {
        1: [-1, +1],
        3: [+1, +1],
        7: [-1, -1],
        9: [+1, -1]
      };
      rTile.x += dir[delta][0];
      rTile.y += dir[delta][1];
      rTile.facing = reverse(delta);
      return rTile;
    };
    tilesToTheSide = function(tile) {
      return {
        1: [3, 7],
        3: [1, 9],
        7: [1, 9],
        9: [3, 7]
      }[tile.facing].map(function(dir) {
        return relativeTile(tile, dir);
      });
    };
    validPropertyLocation = function(tile, index, tileList) {
      return !(index > _.find(_.range(tileList.length), function(tIndex) {
        return pointsAreEqual(tile, tileList[tIndex]);
      })) && !(_.find(roadTiles, function(road) {
        return pointsAreEqual(tile, road);
      }));
    };
    existingProperties = _.chain(roadTiles).map(function(roadTile) {
      var propertyLocations;
      propertyLocations = [];
      if (!roadTile.connects[1] && Math.random() < 0.75) {
        propertyLocations.push(relativeTile(roadTile, 1));
      }
      if (!roadTile.connects[3] && Math.random() < 0.75) {
        propertyLocations.push(relativeTile(roadTile, 3));
      }
      if (!roadTile.connects[7] && Math.random() < 0.75) {
        propertyLocations.push(relativeTile(roadTile, 7));
      }
      if (!roadTile.connects[9] && Math.random() < 0.75) {
        propertyLocations.push(relativeTile(roadTile, 9));
      }
      return propertyLocations;
    }).flatten().shuffle().filter(validPropertyLocation).map(function(prop, index) {
      prop.front = true;
      prop.address = index;
      prop.priority = 1;
      return prop;
    }).map(function(prop) {
      var newProp;
      newProp = relativeTile(prop, reverse(prop.facing));
      newProp.address = prop.address;
      newProp.priority = 2;
      return [prop, newProp];
    }).flatten().map(function(plot) {
      return tilesToTheSide(plot).map(function(newPlot) {
        newPlot.address = plot.address;
        newPlot.priority = 3;
        return newPlot;
      }).concat(plot);
    }).flatten().sortBy('priority').filter(validPropertyLocation).groupBy('address').values().value();
    return existingProperties.forEach(function(prop) {
      return populateProperty(prop);
    });
  };

  commercialUndesirability = function(pointA, pointB) {
    c.log((!commercialAxisIsVertical) + 1, commercialAxisIsVertical + 1);
    return Math.abs(pointA.x - pointB.x) / ((!commercialAxisIsVertical) + 1) + Math.abs(pointA.y - pointB.y) / (commercialAxisIsVertical + 1);
  };

}).call(this);
